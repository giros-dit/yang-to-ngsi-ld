# coding: utf-8

"""
    OpenAPI schemas for YANG data models netflow-v9.yang, netflow-v9-agg.yang, ietf-inet-types@2021-02-22.yang, ietf-yang-types@2023-01-23.yang.

    OpenAPI schemas for YANG data models compliant with the NGSI-LD OAS V1.6.1 metamodel according to ETSI GS CIM 009 V1.6.1.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from ngsi_ld_models.models.bytes_in_per_packet import BytesInPerPacket
from ngsi_ld_models.models.bytes_in_per_second import BytesInPerSecond
from ngsi_ld_models.models.bytes_out import BytesOut
from ngsi_ld_models.models.bytes_out_mul import BytesOutMul
from ngsi_ld_models.models.bytes_out_per_packet import BytesOutPerPacket
from ngsi_ld_models.models.bytes_out_per_second import BytesOutPerSecond
from ngsi_ld_models.models.direction import Direction
from ngsi_ld_models.models.dst_mac_in import DstMacIn
from ngsi_ld_models.models.dst_mac_out import DstMacOut
from ngsi_ld_models.models.dst_port import DstPort
from ngsi_ld_models.models.dst_tos import DstTos
from ngsi_ld_models.models.engine_id import EngineId
from ngsi_ld_models.models.engine_type import EngineType
from ngsi_ld_models.models.entity_scope import EntityScope
from ngsi_ld_models.models.export_packet_flow_data_record_bytes_in import ExportPacketFlowDataRecordBytesIn
from ngsi_ld_models.models.export_packet_flow_data_record_pkts_in import ExportPacketFlowDataRecordPktsIn
from ngsi_ld_models.models.first_switched import FirstSwitched
from ngsi_ld_models.models.flow_active_tout import FlowActiveTout
from ngsi_ld_models.models.flow_duration import FlowDuration
from ngsi_ld_models.models.flow_id import FlowId
from ngsi_ld_models.models.flow_inactive_tout import FlowInactiveTout
from ngsi_ld_models.models.flow_sampler_id import FlowSamplerId
from ngsi_ld_models.models.flow_sampler_mode import FlowSamplerMode
from ngsi_ld_models.models.flow_sampler_random import FlowSamplerRandom
from ngsi_ld_models.models.flows import Flows
from ngsi_ld_models.models.forwarding_status import ForwardingStatus
from ngsi_ld_models.models.frag_offset import FragOffset
from ngsi_ld_models.models.geo_property import GeoProperty
from ngsi_ld_models.models.icmp_type import IcmpType
from ngsi_ld_models.models.if_desc import IfDesc
from ngsi_ld_models.models.if_name import IfName
from ngsi_ld_models.models.igmp_type import IgmpType
from ngsi_ld_models.models.ip_version import IpVersion
from ngsi_ld_models.models.is_part_of import IsPartOf
from ngsi_ld_models.models.last_switched import LastSwitched
from ngsi_ld_models.models.max_pkt_len import MaxPktLen
from ngsi_ld_models.models.max_ttl import MaxTtl
from ngsi_ld_models.models.min_pkt_len import MinPktLen
from ngsi_ld_models.models.min_ttl import MinTtl
from ngsi_ld_models.models.pkts_in_per_second import PktsInPerSecond
from ngsi_ld_models.models.pkts_out import PktsOut
from ngsi_ld_models.models.pkts_out_mul import PktsOutMul
from ngsi_ld_models.models.pkts_out_per_second import PktsOutPerSecond
from ngsi_ld_models.models.postip_dscp import PostipDscp
from ngsi_ld_models.models.protocol import Protocol
from ngsi_ld_models.models.ratio_bytes_in_per_out import RatioBytesInPerOut
from ngsi_ld_models.models.ratio_pkts_in_per_out import RatioPktsInPerOut
from ngsi_ld_models.models.repl_factor_mul import ReplFactorMul
from ngsi_ld_models.models.sampler_name import SamplerName
from ngsi_ld_models.models.sampling_algorithm import SamplingAlgorithm
from ngsi_ld_models.models.sampling_interval import SamplingInterval
from ngsi_ld_models.models.snmp_in import SnmpIn
from ngsi_ld_models.models.snmp_out import SnmpOut
from ngsi_ld_models.models.src_mac_in import SrcMacIn
from ngsi_ld_models.models.src_mac_out import SrcMacOut
from ngsi_ld_models.models.src_port import SrcPort
from ngsi_ld_models.models.src_tos import SrcTos
from ngsi_ld_models.models.tcp_flags import TcpFlags
from ngsi_ld_models.models.tot_bytes_exp import TotBytesExp
from ngsi_ld_models.models.tot_flows_exp import TotFlowsExp
from ngsi_ld_models.models.tot_pkts_exp import TotPktsExp
from typing import Optional, Set
from typing_extensions import Self

class ExportPacketFlowDataRecord(BaseModel):
    """
    This list contains all possible fields of a Flow Data Record sent in a Export Packet  YANG module: netflow-v9.yang 
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Entity id. ")
    type: StrictStr = Field(description="NGSI-LD Entity identifier. It has to be ExportPacketFlowDataRecord.")
    scope: Optional[EntityScope] = None
    location: Optional[GeoProperty] = None
    observation_space: Optional[GeoProperty] = Field(default=None, alias="observationSpace")
    operation_space: Optional[GeoProperty] = Field(default=None, alias="operationSpace")
    created_at: Optional[datetime] = Field(default=None, description="Is defined as the temporal Property at which the Entity, Property or Relationship was entered into an NGSI-LD system. ", alias="createdAt")
    modified_at: Optional[datetime] = Field(default=None, description="Is defined as the temporal Property at which the Entity, Property or Relationship was last modified in an NGSI-LD system, e.g. in order to correct a previously entered incorrect value. ", alias="modifiedAt")
    deleted_at: Optional[datetime] = Field(default=None, description="Is defined as the temporal Property at which the Entity, Property or Relationship was deleted from an NGSI-LD system.  Entity deletion timestamp. See clause 4.8 It is only used in notifications reporting deletions and in the Temporal Representation of Entities (clause 4.5.6), Properties (clause 4.5.7), Relationships (clause 4.5.8) and LanguageProperties (clause 5.2.32). ", alias="deletedAt")
    flow_id: Optional[FlowId] = Field(default=None, alias="flowId")
    bytes_in: ExportPacketFlowDataRecordBytesIn = Field(alias="bytesIn")
    bytes_out: Optional[BytesOut] = Field(default=None, alias="bytesOut")
    pkts_in: ExportPacketFlowDataRecordPktsIn = Field(alias="pktsIn")
    pkts_out: Optional[PktsOut] = Field(default=None, alias="pktsOut")
    flows: Optional[Flows] = None
    protocol: Protocol
    src_tos: Optional[SrcTos] = Field(default=None, alias="srcTos")
    dst_tos: Optional[DstTos] = Field(default=None, alias="dstTos")
    tcp_flags: Optional[TcpFlags] = Field(default=None, alias="tcpFlags")
    src_port: SrcPort = Field(alias="srcPort")
    dst_port: DstPort = Field(alias="dstPort")
    snmp_in: Optional[SnmpIn] = Field(default=None, alias="snmpIn")
    snmp_out: Optional[SnmpOut] = Field(default=None, alias="snmpOut")
    bytes_out_mul: Optional[BytesOutMul] = Field(default=None, alias="bytesOutMul")
    pkts_out_mul: Optional[PktsOutMul] = Field(default=None, alias="pktsOutMul")
    first_switched: FirstSwitched = Field(alias="firstSwitched")
    last_switched: LastSwitched = Field(alias="lastSwitched")
    min_pkt_len: Optional[MinPktLen] = Field(default=None, alias="minPktLen")
    max_pkt_len: Optional[MaxPktLen] = Field(default=None, alias="maxPktLen")
    icmp_type: Optional[IcmpType] = Field(default=None, alias="icmpType")
    igmp_type: Optional[IgmpType] = Field(default=None, alias="igmpType")
    sampler_name: Optional[SamplerName] = Field(default=None, alias="samplerName")
    sampling_interval: Optional[SamplingInterval] = Field(default=None, alias="samplingInterval")
    sampling_algorithm: Optional[SamplingAlgorithm] = Field(default=None, alias="samplingAlgorithm")
    flow_active_tout: Optional[FlowActiveTout] = Field(default=None, alias="flowActiveTout")
    flow_inactive_tout: Optional[FlowInactiveTout] = Field(default=None, alias="flowInactiveTout")
    engine_type: Optional[EngineType] = Field(default=None, alias="engineType")
    engine_id: Optional[EngineId] = Field(default=None, alias="engineId")
    tot_bytes_exp: Optional[TotBytesExp] = Field(default=None, alias="totBytesExp")
    tot_pkts_exp: Optional[TotPktsExp] = Field(default=None, alias="totPktsExp")
    tot_flows_exp: Optional[TotFlowsExp] = Field(default=None, alias="totFlowsExp")
    flow_sampler_id: Optional[FlowSamplerId] = Field(default=None, alias="flowSamplerId")
    flow_sampler_mode: Optional[FlowSamplerMode] = Field(default=None, alias="flowSamplerMode")
    flow_sampler_random: Optional[FlowSamplerRandom] = Field(default=None, alias="flowSamplerRandom")
    min_ttl: Optional[MinTtl] = Field(default=None, alias="minTtl")
    max_ttl: Optional[MaxTtl] = Field(default=None, alias="maxTtl")
    src_mac_in: SrcMacIn = Field(alias="srcMacIn")
    dst_mac_in: DstMacIn = Field(alias="dstMacIn")
    src_mac_out: Optional[SrcMacOut] = Field(default=None, alias="srcMacOut")
    dst_mac_out: Optional[DstMacOut] = Field(default=None, alias="dstMacOut")
    ip_version: IpVersion = Field(alias="ipVersion")
    direction: Optional[Direction] = None
    if_name: Optional[IfName] = Field(default=None, alias="ifName")
    if_desc: Optional[IfDesc] = Field(default=None, alias="ifDesc")
    frag_offset: Optional[FragOffset] = Field(default=None, alias="fragOffset")
    forwarding_status: Optional[ForwardingStatus] = Field(default=None, alias="forwardingStatus")
    postip_dscp: Optional[PostipDscp] = Field(default=None, alias="postipDscp")
    repl_factor_mul: Optional[ReplFactorMul] = Field(default=None, alias="replFactorMul")
    flow_duration: Optional[FlowDuration] = Field(default=None, alias="flowDuration")
    bytes_in_per_second: Optional[BytesInPerSecond] = Field(default=None, alias="bytesInPerSecond")
    bytes_out_per_second: Optional[BytesOutPerSecond] = Field(default=None, alias="bytesOutPerSecond")
    pkts_in_per_second: Optional[PktsInPerSecond] = Field(default=None, alias="pktsInPerSecond")
    pkts_out_per_second: Optional[PktsOutPerSecond] = Field(default=None, alias="pktsOutPerSecond")
    bytes_in_per_packet: Optional[BytesInPerPacket] = Field(default=None, alias="bytesInPerPacket")
    bytes_out_per_packet: Optional[BytesOutPerPacket] = Field(default=None, alias="bytesOutPerPacket")
    ratio_bytes_in_per_out: Optional[RatioBytesInPerOut] = Field(default=None, alias="ratioBytesInPerOut")
    ratio_pkts_in_per_out: Optional[RatioPktsInPerOut] = Field(default=None, alias="ratioPktsInPerOut")
    is_part_of: IsPartOf = Field(alias="isPartOf")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "type", "scope", "location", "observationSpace", "operationSpace", "createdAt", "modifiedAt", "deletedAt", "flowId", "bytesIn", "bytesOut", "pktsIn", "pktsOut", "flows", "protocol", "srcTos", "dstTos", "tcpFlags", "srcPort", "dstPort", "snmpIn", "snmpOut", "bytesOutMul", "pktsOutMul", "firstSwitched", "lastSwitched", "minPktLen", "maxPktLen", "icmpType", "igmpType", "samplerName", "samplingInterval", "samplingAlgorithm", "flowActiveTout", "flowInactiveTout", "engineType", "engineId", "totBytesExp", "totPktsExp", "totFlowsExp", "flowSamplerId", "flowSamplerMode", "flowSamplerRandom", "minTtl", "maxTtl", "srcMacIn", "dstMacIn", "srcMacOut", "dstMacOut", "ipVersion", "direction", "ifName", "ifDesc", "fragOffset", "forwardingStatus", "postipDscp", "replFactorMul", "flowDuration", "bytesInPerSecond", "bytesOutPerSecond", "pktsInPerSecond", "pktsOutPerSecond", "bytesInPerPacket", "bytesOutPerPacket", "ratioBytesInPerOut", "ratioPktsInPerOut", "isPartOf"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('ExportPacketFlowDataRecord'):
            raise ValueError("must be one of enum values ('ExportPacketFlowDataRecord')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ExportPacketFlowDataRecord from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "created_at",
            "modified_at",
            "deleted_at",
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of scope
        if self.scope:
            _dict['scope'] = self.scope.to_dict()
        # override the default output from pydantic by calling `to_dict()` of location
        if self.location:
            _dict['location'] = self.location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of observation_space
        if self.observation_space:
            _dict['observationSpace'] = self.observation_space.to_dict()
        # override the default output from pydantic by calling `to_dict()` of operation_space
        if self.operation_space:
            _dict['operationSpace'] = self.operation_space.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_id
        if self.flow_id:
            _dict['flowId'] = self.flow_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_in
        if self.bytes_in:
            _dict['bytesIn'] = self.bytes_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_out
        if self.bytes_out:
            _dict['bytesOut'] = self.bytes_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pkts_in
        if self.pkts_in:
            _dict['pktsIn'] = self.pkts_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pkts_out
        if self.pkts_out:
            _dict['pktsOut'] = self.pkts_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flows
        if self.flows:
            _dict['flows'] = self.flows.to_dict()
        # override the default output from pydantic by calling `to_dict()` of protocol
        if self.protocol:
            _dict['protocol'] = self.protocol.to_dict()
        # override the default output from pydantic by calling `to_dict()` of src_tos
        if self.src_tos:
            _dict['srcTos'] = self.src_tos.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dst_tos
        if self.dst_tos:
            _dict['dstTos'] = self.dst_tos.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tcp_flags
        if self.tcp_flags:
            _dict['tcpFlags'] = self.tcp_flags.to_dict()
        # override the default output from pydantic by calling `to_dict()` of src_port
        if self.src_port:
            _dict['srcPort'] = self.src_port.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dst_port
        if self.dst_port:
            _dict['dstPort'] = self.dst_port.to_dict()
        # override the default output from pydantic by calling `to_dict()` of snmp_in
        if self.snmp_in:
            _dict['snmpIn'] = self.snmp_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of snmp_out
        if self.snmp_out:
            _dict['snmpOut'] = self.snmp_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_out_mul
        if self.bytes_out_mul:
            _dict['bytesOutMul'] = self.bytes_out_mul.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pkts_out_mul
        if self.pkts_out_mul:
            _dict['pktsOutMul'] = self.pkts_out_mul.to_dict()
        # override the default output from pydantic by calling `to_dict()` of first_switched
        if self.first_switched:
            _dict['firstSwitched'] = self.first_switched.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_switched
        if self.last_switched:
            _dict['lastSwitched'] = self.last_switched.to_dict()
        # override the default output from pydantic by calling `to_dict()` of min_pkt_len
        if self.min_pkt_len:
            _dict['minPktLen'] = self.min_pkt_len.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_pkt_len
        if self.max_pkt_len:
            _dict['maxPktLen'] = self.max_pkt_len.to_dict()
        # override the default output from pydantic by calling `to_dict()` of icmp_type
        if self.icmp_type:
            _dict['icmpType'] = self.icmp_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of igmp_type
        if self.igmp_type:
            _dict['igmpType'] = self.igmp_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sampler_name
        if self.sampler_name:
            _dict['samplerName'] = self.sampler_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sampling_interval
        if self.sampling_interval:
            _dict['samplingInterval'] = self.sampling_interval.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sampling_algorithm
        if self.sampling_algorithm:
            _dict['samplingAlgorithm'] = self.sampling_algorithm.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_active_tout
        if self.flow_active_tout:
            _dict['flowActiveTout'] = self.flow_active_tout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_inactive_tout
        if self.flow_inactive_tout:
            _dict['flowInactiveTout'] = self.flow_inactive_tout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of engine_type
        if self.engine_type:
            _dict['engineType'] = self.engine_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of engine_id
        if self.engine_id:
            _dict['engineId'] = self.engine_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tot_bytes_exp
        if self.tot_bytes_exp:
            _dict['totBytesExp'] = self.tot_bytes_exp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tot_pkts_exp
        if self.tot_pkts_exp:
            _dict['totPktsExp'] = self.tot_pkts_exp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tot_flows_exp
        if self.tot_flows_exp:
            _dict['totFlowsExp'] = self.tot_flows_exp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_sampler_id
        if self.flow_sampler_id:
            _dict['flowSamplerId'] = self.flow_sampler_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_sampler_mode
        if self.flow_sampler_mode:
            _dict['flowSamplerMode'] = self.flow_sampler_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_sampler_random
        if self.flow_sampler_random:
            _dict['flowSamplerRandom'] = self.flow_sampler_random.to_dict()
        # override the default output from pydantic by calling `to_dict()` of min_ttl
        if self.min_ttl:
            _dict['minTtl'] = self.min_ttl.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_ttl
        if self.max_ttl:
            _dict['maxTtl'] = self.max_ttl.to_dict()
        # override the default output from pydantic by calling `to_dict()` of src_mac_in
        if self.src_mac_in:
            _dict['srcMacIn'] = self.src_mac_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dst_mac_in
        if self.dst_mac_in:
            _dict['dstMacIn'] = self.dst_mac_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of src_mac_out
        if self.src_mac_out:
            _dict['srcMacOut'] = self.src_mac_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dst_mac_out
        if self.dst_mac_out:
            _dict['dstMacOut'] = self.dst_mac_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ip_version
        if self.ip_version:
            _dict['ipVersion'] = self.ip_version.to_dict()
        # override the default output from pydantic by calling `to_dict()` of direction
        if self.direction:
            _dict['direction'] = self.direction.to_dict()
        # override the default output from pydantic by calling `to_dict()` of if_name
        if self.if_name:
            _dict['ifName'] = self.if_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of if_desc
        if self.if_desc:
            _dict['ifDesc'] = self.if_desc.to_dict()
        # override the default output from pydantic by calling `to_dict()` of frag_offset
        if self.frag_offset:
            _dict['fragOffset'] = self.frag_offset.to_dict()
        # override the default output from pydantic by calling `to_dict()` of forwarding_status
        if self.forwarding_status:
            _dict['forwardingStatus'] = self.forwarding_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of postip_dscp
        if self.postip_dscp:
            _dict['postipDscp'] = self.postip_dscp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of repl_factor_mul
        if self.repl_factor_mul:
            _dict['replFactorMul'] = self.repl_factor_mul.to_dict()
        # override the default output from pydantic by calling `to_dict()` of flow_duration
        if self.flow_duration:
            _dict['flowDuration'] = self.flow_duration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_in_per_second
        if self.bytes_in_per_second:
            _dict['bytesInPerSecond'] = self.bytes_in_per_second.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_out_per_second
        if self.bytes_out_per_second:
            _dict['bytesOutPerSecond'] = self.bytes_out_per_second.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pkts_in_per_second
        if self.pkts_in_per_second:
            _dict['pktsInPerSecond'] = self.pkts_in_per_second.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pkts_out_per_second
        if self.pkts_out_per_second:
            _dict['pktsOutPerSecond'] = self.pkts_out_per_second.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_in_per_packet
        if self.bytes_in_per_packet:
            _dict['bytesInPerPacket'] = self.bytes_in_per_packet.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_out_per_packet
        if self.bytes_out_per_packet:
            _dict['bytesOutPerPacket'] = self.bytes_out_per_packet.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ratio_bytes_in_per_out
        if self.ratio_bytes_in_per_out:
            _dict['ratioBytesInPerOut'] = self.ratio_bytes_in_per_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ratio_pkts_in_per_out
        if self.ratio_pkts_in_per_out:
            _dict['ratioPktsInPerOut'] = self.ratio_pkts_in_per_out.to_dict()
        # override the default output from pydantic by calling `to_dict()` of is_part_of
        if self.is_part_of:
            _dict['isPartOf'] = self.is_part_of.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ExportPacketFlowDataRecord from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "type": obj.get("type") if obj.get("type") is not None else 'ExportPacketFlowDataRecord',
            "scope": EntityScope.from_dict(obj["scope"]) if obj.get("scope") is not None else None,
            "location": GeoProperty.from_dict(obj["location"]) if obj.get("location") is not None else None,
            "observationSpace": GeoProperty.from_dict(obj["observationSpace"]) if obj.get("observationSpace") is not None else None,
            "operationSpace": GeoProperty.from_dict(obj["operationSpace"]) if obj.get("operationSpace") is not None else None,
            "createdAt": obj.get("createdAt"),
            "modifiedAt": obj.get("modifiedAt"),
            "deletedAt": obj.get("deletedAt"),
            "flowId": FlowId.from_dict(obj["flowId"]) if obj.get("flowId") is not None else None,
            "bytesIn": ExportPacketFlowDataRecordBytesIn.from_dict(obj["bytesIn"]) if obj.get("bytesIn") is not None else None,
            "bytesOut": BytesOut.from_dict(obj["bytesOut"]) if obj.get("bytesOut") is not None else None,
            "pktsIn": ExportPacketFlowDataRecordPktsIn.from_dict(obj["pktsIn"]) if obj.get("pktsIn") is not None else None,
            "pktsOut": PktsOut.from_dict(obj["pktsOut"]) if obj.get("pktsOut") is not None else None,
            "flows": Flows.from_dict(obj["flows"]) if obj.get("flows") is not None else None,
            "protocol": Protocol.from_dict(obj["protocol"]) if obj.get("protocol") is not None else None,
            "srcTos": SrcTos.from_dict(obj["srcTos"]) if obj.get("srcTos") is not None else None,
            "dstTos": DstTos.from_dict(obj["dstTos"]) if obj.get("dstTos") is not None else None,
            "tcpFlags": TcpFlags.from_dict(obj["tcpFlags"]) if obj.get("tcpFlags") is not None else None,
            "srcPort": SrcPort.from_dict(obj["srcPort"]) if obj.get("srcPort") is not None else None,
            "dstPort": DstPort.from_dict(obj["dstPort"]) if obj.get("dstPort") is not None else None,
            "snmpIn": SnmpIn.from_dict(obj["snmpIn"]) if obj.get("snmpIn") is not None else None,
            "snmpOut": SnmpOut.from_dict(obj["snmpOut"]) if obj.get("snmpOut") is not None else None,
            "bytesOutMul": BytesOutMul.from_dict(obj["bytesOutMul"]) if obj.get("bytesOutMul") is not None else None,
            "pktsOutMul": PktsOutMul.from_dict(obj["pktsOutMul"]) if obj.get("pktsOutMul") is not None else None,
            "firstSwitched": FirstSwitched.from_dict(obj["firstSwitched"]) if obj.get("firstSwitched") is not None else None,
            "lastSwitched": LastSwitched.from_dict(obj["lastSwitched"]) if obj.get("lastSwitched") is not None else None,
            "minPktLen": MinPktLen.from_dict(obj["minPktLen"]) if obj.get("minPktLen") is not None else None,
            "maxPktLen": MaxPktLen.from_dict(obj["maxPktLen"]) if obj.get("maxPktLen") is not None else None,
            "icmpType": IcmpType.from_dict(obj["icmpType"]) if obj.get("icmpType") is not None else None,
            "igmpType": IgmpType.from_dict(obj["igmpType"]) if obj.get("igmpType") is not None else None,
            "samplerName": SamplerName.from_dict(obj["samplerName"]) if obj.get("samplerName") is not None else None,
            "samplingInterval": SamplingInterval.from_dict(obj["samplingInterval"]) if obj.get("samplingInterval") is not None else None,
            "samplingAlgorithm": SamplingAlgorithm.from_dict(obj["samplingAlgorithm"]) if obj.get("samplingAlgorithm") is not None else None,
            "flowActiveTout": FlowActiveTout.from_dict(obj["flowActiveTout"]) if obj.get("flowActiveTout") is not None else None,
            "flowInactiveTout": FlowInactiveTout.from_dict(obj["flowInactiveTout"]) if obj.get("flowInactiveTout") is not None else None,
            "engineType": EngineType.from_dict(obj["engineType"]) if obj.get("engineType") is not None else None,
            "engineId": EngineId.from_dict(obj["engineId"]) if obj.get("engineId") is not None else None,
            "totBytesExp": TotBytesExp.from_dict(obj["totBytesExp"]) if obj.get("totBytesExp") is not None else None,
            "totPktsExp": TotPktsExp.from_dict(obj["totPktsExp"]) if obj.get("totPktsExp") is not None else None,
            "totFlowsExp": TotFlowsExp.from_dict(obj["totFlowsExp"]) if obj.get("totFlowsExp") is not None else None,
            "flowSamplerId": FlowSamplerId.from_dict(obj["flowSamplerId"]) if obj.get("flowSamplerId") is not None else None,
            "flowSamplerMode": FlowSamplerMode.from_dict(obj["flowSamplerMode"]) if obj.get("flowSamplerMode") is not None else None,
            "flowSamplerRandom": FlowSamplerRandom.from_dict(obj["flowSamplerRandom"]) if obj.get("flowSamplerRandom") is not None else None,
            "minTtl": MinTtl.from_dict(obj["minTtl"]) if obj.get("minTtl") is not None else None,
            "maxTtl": MaxTtl.from_dict(obj["maxTtl"]) if obj.get("maxTtl") is not None else None,
            "srcMacIn": SrcMacIn.from_dict(obj["srcMacIn"]) if obj.get("srcMacIn") is not None else None,
            "dstMacIn": DstMacIn.from_dict(obj["dstMacIn"]) if obj.get("dstMacIn") is not None else None,
            "srcMacOut": SrcMacOut.from_dict(obj["srcMacOut"]) if obj.get("srcMacOut") is not None else None,
            "dstMacOut": DstMacOut.from_dict(obj["dstMacOut"]) if obj.get("dstMacOut") is not None else None,
            "ipVersion": IpVersion.from_dict(obj["ipVersion"]) if obj.get("ipVersion") is not None else None,
            "direction": Direction.from_dict(obj["direction"]) if obj.get("direction") is not None else None,
            "ifName": IfName.from_dict(obj["ifName"]) if obj.get("ifName") is not None else None,
            "ifDesc": IfDesc.from_dict(obj["ifDesc"]) if obj.get("ifDesc") is not None else None,
            "fragOffset": FragOffset.from_dict(obj["fragOffset"]) if obj.get("fragOffset") is not None else None,
            "forwardingStatus": ForwardingStatus.from_dict(obj["forwardingStatus"]) if obj.get("forwardingStatus") is not None else None,
            "postipDscp": PostipDscp.from_dict(obj["postipDscp"]) if obj.get("postipDscp") is not None else None,
            "replFactorMul": ReplFactorMul.from_dict(obj["replFactorMul"]) if obj.get("replFactorMul") is not None else None,
            "flowDuration": FlowDuration.from_dict(obj["flowDuration"]) if obj.get("flowDuration") is not None else None,
            "bytesInPerSecond": BytesInPerSecond.from_dict(obj["bytesInPerSecond"]) if obj.get("bytesInPerSecond") is not None else None,
            "bytesOutPerSecond": BytesOutPerSecond.from_dict(obj["bytesOutPerSecond"]) if obj.get("bytesOutPerSecond") is not None else None,
            "pktsInPerSecond": PktsInPerSecond.from_dict(obj["pktsInPerSecond"]) if obj.get("pktsInPerSecond") is not None else None,
            "pktsOutPerSecond": PktsOutPerSecond.from_dict(obj["pktsOutPerSecond"]) if obj.get("pktsOutPerSecond") is not None else None,
            "bytesInPerPacket": BytesInPerPacket.from_dict(obj["bytesInPerPacket"]) if obj.get("bytesInPerPacket") is not None else None,
            "bytesOutPerPacket": BytesOutPerPacket.from_dict(obj["bytesOutPerPacket"]) if obj.get("bytesOutPerPacket") is not None else None,
            "ratioBytesInPerOut": RatioBytesInPerOut.from_dict(obj["ratioBytesInPerOut"]) if obj.get("ratioBytesInPerOut") is not None else None,
            "ratioPktsInPerOut": RatioPktsInPerOut.from_dict(obj["ratioPktsInPerOut"]) if obj.get("ratioPktsInPerOut") is not None else None,
            "isPartOf": IsPartOf.from_dict(obj["isPartOf"]) if obj.get("isPartOf") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


